<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Empty Train</title>
		<style>
			html, body {
				margin: 0;
				padding: 0;
				height: 100%;
				overflow: hidden;
			}

			body {
				font: 16px/24px sans-serif;
			}

			#app {
				height: 100%;
				display: flex;
				flex-direction: column;
				opacity: 0;
				transition: opacity ease-in-out 150ms;
			}

			#app[data-v-app] {
				opacity: 1.0;
			}

			.controls {
				flex: 0;
				border-bottom: 1px solid #ccc;
			}

			.main {
				flex: 1;
				display: flex;
				overflow: hidden;
			}

			.filter-output {
				display: flex;
				flex-direction: column;
				flex: 1 1 auto;
/*				overflow: hidden;*/
			}

			.filter-error {
				border-top: 1px solid #ccc;
				flex: 0 0 auto;
				overflow: hidden;
				overflow-y: auto;
			}

			.filter-error pre {
				white-space: pre-wrap;
			}

			.sample {
				flex: 1 1 auto;
				overflow-y: auto;
			}

			.sample table {
				table-layout: fixed;
				border-collapse: collapse;
			}

			.sample table td {
				width: 50%;
				padding: 0.25em 0.5em;
				vertical-align: top;
			}

			.sample table tr:nth-child(2n) td {
				background: #eef;
			}

			.sample table tr.added td {
				background: #efe;
			}

			.sample table tr.removed td {
				background: #fee;
			}

			.sample table tr.changed td {
				background: #ffe;
			}

			.sample.display-as-rows table thead {
				display: none;
			}

			.sample.display-as-rows table tr {
				display: block;
				margin-bottom: 1em;
			}

			.sample.display-as-rows table td {
				display: block;
				width: auto;
			}

			.sample.display-as-rows td[lang]::before {
				content: attr(lang) ': ';
				display: inline-block;
				margin: 0 0.5em 0 0;
				opacity: 0.5;
			}

			.filters {
				display: flex;
				flex-direction: column;
				flex: 0 0 300px;
				border-left: 1px solid #ccc;
			}

			.available-filters {
				flex: 0;
			}

			.filter-steps {
				flex: 1;
				border-top: 1px solid #ccc;
				overflow-y: auto;
			}

			.filter {
				display: flex;
			}

			.filter .filter-name {
				flex: 2;
			}

			.filter .filter-type {
				flex: 1;
				font-size: 0.8em;
				padding-left: 0.5em;
			}

			.filter .add-filter-btn {
				flex: 0;
				align-self: center;
			}

			.filter-steps li {
				margin: 1em 0;
				position: relative; /* for ::after arrow */
				background: white; /* for draggable */
			}

			.filter-steps li.selected {
				box-shadow: 0 0 0 4px rgba(0, 0, 255, 0.5);
			}

			.filter-steps li:not(:last-child):not(.selected)::after {
				content: '';
				width: 0;
				height: 0;
				border-top: 1em solid #ccc;
				border-left: 1em solid transparent;
				border-right: 1em solid transparent;
				position: absolute;
				left: calc(50% - 1em);
			}

			.controls, .available-filters, .filter-steps {
				margin: 0;
				padding: 0.5em 1em;
				list-style: none;
			}

			input[type=number] {
				width: 5em;
			}

			input[type=checkbox] {
				width: 1em;
			}

			.property-list {
				border: 1px solid #ccc;
				border-radius: 4px;
			}

			.property-list > *:not(:last-child) {
				border-bottom: 1px solid #ccc;
			}

			.property-list > header {
				background: #ccc;
			}

			.property-list > header > button {
				align-self: flex-end;
			}

			.property-list > * {
				padding: 0.5em;
				display: flex;
				flex-wrap: wrap;
			}

			.property-list > * > * {
				flex: 0;
				align-self: center;
			}

			.property-list > * > *:first-child {
				flex: 1;
				align-self: flex-start;
			}

			.property-list > * > small {
				flex: 1 0 100%;
			}

			.property-list > * > input[type=checkbox] {
				flex-basis: 1em;
			}

		</style>
	</head>
	<body>
		<div id="app">
			<div class="controls">
				<label>
					Dataset:
					<select v-model="selectedDataset">
						<option v-for="dataset in datasets" v-bind:value="dataset">{{ dataset.name }}</option>
					</select>
				</label>

				<label>
					<input type="checkbox" v-model="displayAsRows">
					Display as rows
				</label>

				<button v-on:click="saveFilterSteps" v-bind:disabled="!filterStepsChangedSinceLastSave">Save filtering steps</button>

				<label v-if="isFetchingSamples">Loading sampleâ€¦</label>
			</div>

			<div class="main">
				<div class="filter-output">
					<div v-bind:class="{'sample':true, 'display-as-rows': displayAsRows}">
						<table v-if="sample?.stdout">
							<thead>
								<tr>
									<th v-for="lang in languages">{{lang}}</th>
								</tr>
							</thead>
							<tbody>
								<template v-for="(mutation, i) in sample?.mutations">
									<tr v-for="(entry, j) in mutation.value" v-bind:key="`${i}:${j}`" v-bind:class="{added:mutation.added, removed:mutation.removed, changed:mutation.changed}">
										<td v-for="(text, lang) in entry" v-bind:key="lang" v-bind:lang="lang">{{text}}</td>
									</tr>
								</template>
							</tbody>
						</table>
					</div>
					<div class="filter-error" v-if="sample?.stderr">
						<pre>{{ sample.stderr }}</pre>
					</div>
				</div>

				<div class="filters">
					<draggable tag="ul" class="available-filters"
						v-model="filters" item-key="name"
						v-bind:group="{name:'filters', pull:'clone', put:false}"
						v-bind:sort="false"
						v-bind:clone="createFilterStep">
						<template v-slot:item="{element:filter}">
							<li class="filter">
								<span v-bind:title="filter.description" class="filter-name">{{filter.name}}</span>
								<span class="filter-type">{{filter.type}}</span>
								<button v-on:click="addFilterStep(filter)" class="add-filter-btn">Add</button>
							</li>
						</template>
					</draggable>

					<draggable tag="ol" class="filter-steps"
						v-model="filterSteps" item-key="stamp" 
						v-bind:group="{name:'filters'}"
						v-bind:multi-drag="true"
						v-bind:multi-drag-key="multiDragKey"
						v-on:select="selectFilterStep($event.element)"
						v-on:deselect="deselectFilterStep($event.element)"
						selected-class="selected">
						<template v-slot:header>
							<li class="property-list">
								<header>
									<span>Sample</span>
								</header>
								<footer>
									<button v-on:click="selectedFilterStep={}">Show</button>
								</footer>
							</li>
						</template>
						<template v-slot:item="{element:filterStep, index:i}">
							<li class="property-list">
								<header>
									<span>{{ filterStep.filter }}</span>
									<button v-on:click="removeFilterStep(i)">Remove</button>
								</header>
								<div v-if="filterRequiresLanguage(filterStep)">
									<label v-bind:for="`step-${i}-column`">Column</label>
									<select v-bind:id="`step-${i}-column`" v-model="filterStep.language">
										<option v-for="lang in languages">{{lang}}</option>
									</select>
								</div>
								<div v-for="(parameter, name) in filterDefinition(filterStep).parameters">
									<label v-bind:for="`step-${i}-${name}`">{{ name }}</label>
									<select v-if="parameter.type == 'str' && parameter.allowed_values" v-model="filterStep.parameters[name]" v-bind:id="`step-${i}-${name}`">
										<option v-for="value in parameter.allowed_values" v-bind:value="value">{{value}}</option>
									</select>
									<input v-else-if="parameter.type == 'bool'" type="checkbox" v-model="filterStep.parameters[name]" v-bind:id="`step-${i}-${name}`">
									<input v-else-if="parameter.type == 'int' || parameter.type == 'float'"
										type="number"
										v-model="filterStep.parameters[name]"
										v-bind:id="`step-${i}-${name}`"
										v-bind:min="parameter.min"
										v-bind:max="parameter.max"
										v-bind:step="parameter.type == 'int' ? 1 : 0.1">
									<input v-else type="text" v-model="filterStep.parameters[name]" v-bind:id="`step-${i}-${name}`">
									
									<small v-if="parameter.help" class="property-list-description">{{parameter.help}}</small>
								</div>
								<footer>
									<button v-on:click="selectedFilterStep=filterStep">Show</button>
								</footer>
							</li>
						</template>
					</draggable>
				</div>
			</div>
		</div>
		<!-- because Safari, unfortunately, does not do importmap yet? -->
		<script async src="https://ga.jspm.io/npm:es-module-shims@1.5.8/dist/es-module-shims.js"></script>
		<script type="importmap">
			{
				"imports": {
					"vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
					"sortablejs": "https://unpkg.com/sortablejs@1.15.0/modular/sortable.complete.esm.js",
					"vuedraggable": "/static/vendor/vuedraggable@4.1.0/src/vuedraggable.js"
				}
			}
		</script>
		<script type="module">
			// Docs for Vue@3: https://vuejs.org/guide/introduction.html
			import {createApp} from 'vue';
			// Docs for draggable@4: https://github.com/SortableJS/vue.draggable.next
			import draggable from 'vuedraggable';

			import {diff} from './diff.js';

			// Simple hash function for creating string hashes
			function cyrb53(str, seed = 0) {
				let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
				for (let i = 0, ch; i < str.length; i++) {
					ch = str.charCodeAt(i);
					h1 = Math.imul(h1 ^ ch, 2654435761);
					h2 = Math.imul(h2 ^ ch, 1597334677);
				}
				h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
				h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
				return 4294967296 * (2097151 & h2) + (h1>>>0);
			}

			// Async generator for lines
			// From https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader/read#example_2_-_handling_text_line_by_line
			async function* lineIterator(reader) {
				const decoder = new TextDecoder("utf-8");
				let {value, done} = await reader.read();
				value = value ? decoder.decode(value, {stream: true}) : "";

				const re = /\r\n|\n|\r/gm;
				let startIndex = 0;

				while (true) {
				  let result = re.exec(value);
				  if (result) {
				  	yield value.substring(startIndex, result.index);
				  	startIndex = re.lastIndex;
				  	continue;
				  }
				  
				  if (done)
				  	break;

					let remainder = value.substr(startIndex);
			    ({value, done} = await reader.read());
			    value = remainder + (value ? decoder.decode(value, {stream: true}) : "");
			    startIndex = 0;
			    re.lastIndex = 0;
				}
				
				// if the last line didn't end in a newline char
			  if (startIndex < value.length)
				  yield value.substr(startIndex);
			}

			async function* stream(url, options) {
				const response = await fetch(url, options);
				if (!response.ok)
					throw new Error(await response.text());
				const reader = response.body.getReader();
				for await (let line of lineIterator(reader)) {
					yield JSON.parse(line);
				}
			}

			const app = createApp({
				data() {
					return {
						displayAsRows: false,
						datasets: [],
						selectedDataset: null,
						samples: [],
						isFetchingSamples: false,
						_sampleAbortController: new AbortController(),
						filters: [],
						filterSteps: [],
						filterStepsLastSave: null,
						selectedFilterStep: null
					};
				},

				computed: {
					languages() {
						return this.selectedDataset ? Array.from(Object.keys(this.selectedDataset.columns)).sort() : []
					},
					filterStepsStateHash() {
						return cyrb53(JSON.stringify(this.filterSteps));
					},
					filterStepsChangedSinceLastSave() {
						return this.filterStepsLastSave !== this.filterStepsStateHash;
					},
					multiDragKey() {
						return navigator.platform.match(/^(iP|Mac)/) ? 'Meta' : 'Control';
					},
					sampleIndex() {
						const index = this.selectedFilterStep ? this.filterSteps.indexOf(this.selectedFilterStep) + 1 : -1;
						return index >= 0 ? index : this.samples.length - 1;
					},
					sample() {
						return this.samples.length > this.sampleIndex ? this.samples[this.sampleIndex] : null;
					}
				},

				watch: {
					selectedDataset() {
						this.fetchSample();
						this.fetchFilterSteps();
					},
					filterSteps: {
						deep: true,
						handler() {
							this.fetchSample()
						}
					}
				},

				created() {
					this._serial = 0;
					this._stamps = new WeakMap();
				},

				async mounted() {
					this.fetchDatasets();
					this.fetchFilters();
				},

				components: {
					draggable,
				},

				methods: {
					async fetchDatasets() {
						const response = await fetch('/datasets/');
						this.datasets = await response.json();
					},
					async fetchFilters() {
						const response = await fetch('/filters/');
						// Turn the {name:Filter} map into a [Filter] list and fold the 'name' attribute into the Filter.name property.
						this.filters = Array.from(Object.entries(await response.json()), ([name, value]) => Object.assign(value, {name}));
					},
					async fetchSample() {
						this._sampleAbortController.abort();

						this._sampleAbortController = new AbortController();
						this.isFetchingSamples = true;
						this.samples.splice(0, this.samples.length);

						const response = stream(`/datasets/${encodeURIComponent(this.selectedDataset.name)}/sample`, {
							method: 'POST',
							signal: this._sampleAbortController.signal,
							headers: {
								'Content-Type': 'application/json',
								'Accept': 'application/json',
							},
							body: JSON.stringify(this.filterSteps)
						});

						for await (let sample of response) {
							this.samples.push(this.diffSample(this.samples[this.samples.length - 1], sample));
						}

						this.isFetchingSamples = false;
					},
					async fetchFilterSteps() {
						const response = await fetch(`/datasets/${encodeURIComponent(this.selectedDataset.name)}/configuration`)
						this.filterSteps = await response.json();
						this.filterStepsLastSave = this.filterStepsStateHash;
					},
					async saveFilterSteps() {
						const hash = this.filterStepsStateHash;

						const response = fetch(`/datasets/${encodeURIComponent(this.selectedDataset.name)}/configuration`, {
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
								'Accept': 'application/json'
							},
							body: JSON.stringify(this.filterSteps)
						});

						if (response.ok)
							this.filterStepsLastSave = hash;
						else
							alert(await response.text());
					},
					createFilterStep(filter) {
						return {
							filter: filter.name,
							language: this.filterRequiresLanguage({filter:filter.name}) ? this.languages[0] : null,
							parameters: Object.fromEntries(Object.entries(filter.parameters).map(([key, parameter]) => [key, parameter.default]))
						}
					},
					addFilterStep(filter) {
						this.filterSteps.push(this.createFilterStep(filter));
					},
					removeFilterStep(i) {
						this.filterSteps.splice(i, 1);
					},
					selectFilterStep(filterStep) {
						this.selectedFilterStep = filterStep;
					},
					deselectFilterStep(filterStep) {
						if (this.selectedFilterStep === filterStep)
							this.selectedFilterStep = null;
					},
					filterDefinition(filterStep) {
						return this.filters.find(filter => filter.name === filterStep.filter);
					},
					filterRequiresLanguage(filterStep) {
						return this.filterDefinition(filterStep).type == 'monolingual';
					},
					stamp(obj) {
						if (!this._stamps.has(obj))
							this._stamps.set(obj, ++this._serial);
						return this._stamps.get(obj);
					},
					diffSample(previous, sample) {
						// Only mark different if neither of the columns is the same.
						const equals = (a, b) => !this.languages.every(lang => a[lang] != b[lang]);
						
						// Mark pairs that have exactly the same text on both sides as identical.
						const identical = (a, b) => this.languages.every(lang => a[lang] == b[lang]);

						const mutations = diff(previous?.stdout || [], sample?.stdout || [], {equals});

						let offset = 0;

						// Now also fish out all those rows that appear the same, but have
						// a difference in only one of the languages
						for (let i = 0; i < mutations.length; ++i) {
							if (mutations[i].added) {
								offset -= mutations[i].count;
								continue;
							}

							if (mutations[i].removed) {
								offset += mutations[i].count;
								continue;
							}

							let first, last;

							// Search for the first different sentence pair in this mutation block.
							for (first = 0; first < mutations[i].value.length; ++first) {
								if (!identical(previous.stdout[offset + first], mutations[i].value[first]))
									break;
							}

							// Did we find the first different sentence pair?
							if (first == mutations[i].value.length)
								continue;

							console.assert(Array.isArray(previous.stdout))

							// Find the first line that is identical again, the end of our
							// 'changed' block.
							for (last = first+1; last < mutations[i].value.length; ++last) {
								if (identical(previous.stdout[offset + last], mutations[i].value[last]))
									break;
							}

							// If it's not the first line of the mutation, we need to split it
							// in at least two (maybe three)
							if (first > 0) {
								mutations.splice(i, 0, {count: first, value: mutations[i].value.splice(0, first)})
								++i;
							}

							mutations[i].count = last - first;
							mutations[i].changed = true;

							// If the mutation contains lines that are the same after the
							// changed ones, add those back in as well. Make sure they are
							// evaluated next.
							if (last - first < mutations[i].value.length) {
								const count = mutations[i].value.length - (last - first);
								mutations.splice(i, 0, {count, value: mutations[i].value.splice(last - first, count)});
								// Do not increase i so next iteration looks at this newly added
								// one, there might be more changes here!
							}
						}

						return {
							...sample,
							mutations
						};
					}
				}
			})

			app.mount('#app');

			window.$app = app; // for debugging


		</script>
	</body>
</html>
